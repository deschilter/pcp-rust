% Traits: bounds & associated types

\begin{frame}[fragile,t]{Traits}
    Trait definition:
    \begin{lstlisting}[language=Rust,escapechar=@,label={lst:traits1}]
trait Foo {
    fn get_val() -> String {
        String::from("foo")
    }

}\end{lstlisting}

    \note<1>{
        Rust hat keine Vererbung, aber es gibt Traits \\
        Traits sind die interfaces von Rust, haben aber noch ein paar Eigenheiten \\
        So kann ein Trait erstellt werden \\
        In Traits können Funktionen definiert werden, in diesem Fall mit default implementation
    }

    \pause
    Trait implementation:
    \begin{lstlisting}[language=Rust,escapechar=@,label={lst:traits2}]
struct Bar;

impl Foo for Bar {
    fn get_val() -> String {
        String::from("bar")
    }
}\end{lstlisting}

    \note<2>{
        So kann ein Trait auf einem Struct implementiert werden \\
        In diesem Fall wird der Trait Foo für das Struct Bar implementiert \\
        Dabei wird die default implementation von get_val überschrieben \\
        Traits werden nicht wie bei Java direkt bei der definition des structs implementiert, sondern können komplett
            losgelöst sein => Dies erlaubt ein paar interesannte Dinge:
    }
\end{frame}

\begin{frame}[fragile,t]{Trait Bounds}
    Auf allen die Bar implementieren:
    \begin{lstlisting}[language=Rust,escapechar=@,label={lst:traitbounds1}]
impl<T: Bar> Foo for T {
}\end{lstlisting}

    \note<1>{
        Traits können auch generisch implementiert werden \\
        In diesem Fall wird Foo auf allen structs implementiert, die den Trait Bar implementieren
    }

    \pause Auf allen die Bar1 und Bar2 implementieren:
    \begin{lstlisting}[language=Rust,escapechar=@,label={lst:traitbounds2}]
impl<T: Bar1 + Bar2> Foo for T {
}\end{lstlisting}

    \note<2>{
        Hier wird Foo auf allen structs implementiert, die Bar1 und Bar2 implementieren
    }

    \pause Auf allen:
    \begin{lstlisting}[language=Rust,escapechar=@,label={lst:traitbounds3}]
impl<T> Foo for T {
}\end{lstlisting}

    \note<3>{
        Und so kann ein Trait auf allen Typen implementiert werden
    }

    \pause
    $\longrightarrow$ DEMO

    \note<4>{
        Lasst uns das mal im Code anschauen \\
        DEMO \\
        Ein Nachteil des ganzen ist, was für Traits ein struct implementiert hat kann ist nicht Übersichtlich
    }
\end{frame}
