\documentclass[letterpaper,12pt]{article}
\usepackage{tabularx} % extra features for tabular environment
\usepackage{amsmath}  % improve math presentation
\usepackage{graphicx} % takes care of graphic including machinery
\usepackage[margin=1in,letterpaper]{geometry} % decreases margins
\usepackage{cite} % takes care of citations
\usepackage[final]{hyperref} % adds hyper links inside the generated pdf file
\hypersetup{
    colorlinks=true,       % false: boxed links; true: colored links
    linkcolor=blue,        % color of internal links
    citecolor=blue,        % color of links to bibliography
    filecolor=magenta,     % color of file links
    urlcolor=blue
}
\usepackage{blindtext}
%++++++++++++++++++++++++++++++++++++++++

% Do not indent second paragraph
\setlength{\parindent}{0pt}

\begin{document}

    \title{Programming Concepts \& Paradigms\\Rust}
    \author{Roman Schilter \& Jan-Henrik Preuß\\[0.4cm]{\small Betreuer: Marcel Baumann \& Ruedi Arnold}}
    \date{May 31, 2024}
    \maketitle

%Wenige Seiten (ca. 2-4) reichen durchaus, max. 5 (bei mehr
%gibt's tendenziell Abzug), Inhaltsverzeichnis nicht nötig

    \begin{abstract}
        % Beschreibe das dokument knapp
        Rust ist eine moderne Programmiersprache, die Sicherheit und Geschwindigkeit vereint.
        Sie wurde von Mozilla 2010 entwickelt und ist Open Source.
        Rust hat den Anspruch, die Lücke zwischen Low-Level-Programmiersprachen wie C und C++ und High-Level-Programmiersprachen wie Java und Python zu schließen.
        Dieses Dokument fasst die wichtigsten Konzepte und Paradigmen von Rust im Vergleich zu Java zusammen.
    \end{abstract}

%    Fokus auf wichtige/ interessante/ spezielle Sprach-
%Eigenschaften! (Was anders als bei Java?!...)
%§ Ergänzend zu den Folien
%– Falls interessant/relevant kurze Infos zu Vision,
%Geschichte & Verbreitung
%– Hauptteil: Die Sprache vorstellen (Ihre 3 bis 7
%Fokuspunkte, inkl. Verweise auf Ihren Demo-Code)


    \section{Sprachkonzepte}

    Hier werden die wichtigsten Sprachkonzepte von Rust.

    \blindtext %delete this line

    \subsection{Borrowing \& Move-Semantik}\label{subsec:borrowing-&-move-semantik}

    \subsection{Traits: bounds \& associated types}\label{subsec:traits:-bounds-&-associated-types}
    Rust hat keine Vererbung.
    Die Structs, das equivalent einer Klasse in Rust, können nicht mit einem anderen Struct erweitert werden.
    Es gibt jedoch sogenannte Traits in Rust, welche fast wie die Interfaces in Java sind.
    Traits können Methoden und optional auch eine Default-Implementation für diese Methoden definieren.

    Der grosse Unterschied zwischen Traits und Interfaces ist jedoch, wie die Traits auf für ein Struct implementiert werden.
    Anstatt dass es bei der Definition des Structs angegben wird, ist es in einem separaten Code-Block.
    Das heisst es ist völlig losgelöst von der definition des Structs oder des Traits.
    Ein Beispiel dazu ist im Crate `rust/example-traits`.

    Leider macht es das nicht einfach für den Entwickler, da nicht immer klar ist, welche Traits auf einem Struct implementiert sind.
    Vor allem nicht mit der nächsten Eigenart.

    \subsubsection{Trait Bounds}\label{subsubsec:trait-bounds}
    Anstatt einen Trait fix auf ein Struct zu implementieren, kann dies auch anhand der bereits implementierten Traits gemacht werden.
    Zum Beispiel kann TraitX auf allen Structs implementiert werden, die auch TraitY und TraitZ implementieren.
    So können bestehende Structs oder Traits einfach mit neuen Funktionen erweitert werden.
    Es ist sogar möglich, einen Trait auf allen zu implementieren.
    So kann zum Beispiel eine Funktion auf dem String hinzugefügt werden.
    Ein Beispiel dazu ist im Crate `rust/example-trait-bounds`

    \subsubsection{Traits mit associated types}\label{subsubsec:traits-associated-types}
    Traits unterstützen auch Generische Typen.
    Damit kann ein Trait zum Beispiel auf Struct1 mit einem Integer implementiert werden und auf Struct2 mit einem String.
    In Traits können auch associated types definiert werden.
    Diese types werden bei der implementation gesetzt und erlauben es, wie Generics auch, den Trait Typen unabhängig zu machen.
    Der Unterschied ist allerdings, dass der Typ nur einmal gesetzt werden kann.
    Das heisst wenn der Trait auf unterschiedlichen Structs mit String und mit Integer implementiert wird, kompiliert das Programm nicht.
    Dies ist nützlich, wenn man dies einschränken will.
    So kann eine Library zum Beispiel Traits mit assozierten Typen liefern und muss sich nicht darum kümmern,
        dass die Typen zwischen den Implementationen unterschiedlich sein könnten.
    Ein Beispiel zu Traits mit variablen Typen ist in der Crate `rust/example-traits-associated-types`.

    \subsection{Typestate Programming}\label{subsec:typestate-programming)}
    Typestate Programming ist ein Pattern, mit dem der aktuelle State über den Typ abgebildet wird.
    In Rust bedeutet das, dass jeder State ein Struct ist.
    Jedes Struct hat Methoden, welche eine Instanz eines anderen Structs zurückgeben.
    So kann von einem State zum anderen übergegangen werden.
    Jeder State kann auch zusätzliche Methoden haben, um zusätzliche Informationen zum State zu erhalten.
    Wenn die Structs in einem eigenen Modul sind, kann mit dem Zugriff-Modifier eingeschränkt werden, wie mit den State interagiert wird.
    So kann eingeschränkt werden, welches der initiale State ist und welche Übergänge gemacht werden können.
    Im Crate `rust/example-typestate-programming` gibt es ein Beispiel dazu.

    Rust eignet sich sehr gut für dieses Pattern, da durch die fixe Typisierung die States nicht manipuliert werden können.
    So kann der Entwickler sicherstellen, dass es nie zu einem invaliden Zustand kommen kann.

    \subsection{Concurrency}\label{subsec:concurrency}
    \subsubsection{Threads}\label{subsubsec:threads}
    Threads können in Rust mit der Funktion \texttt{threads::spawn} gestartet werden.
    Als Argument muss eine Funktion ohne Parameter mitgegeben werden, welche schlussendlich im Thread ausgeführt wird.
    Diese Funktion kann einen Wert zurückliefern oder auch mit dem Makro `panic!` einen Fehler werfen.
    `threads::spawn` liefert eine Instanz eines Threads zurück.
    Darauf kann die blockierende Funktion `join` aufgerufen, welche ein Resultat zurückliefert.
    Auf diesem Resultat kann geprüft werden, ob der Thread "gepanicked" hat oder den Rückgabewert auslesen.
    Ein Beispiel dazu ist im Create `rust/example-threads`.

    \subsubsection{Channels}\label{subsubsec:channels}
    Channels erlauben die Kommunikation zwischen zwei Threads in Rust.
    Dabei kann eine Variable von einem Thread an einen anderen geschickt werden.
    Die Funktion `channel()` liefert ein Tupel mit einem Receiver und einem Sender zurück.
    Diese können dann jeweils einem Thread übergeben werden.

    Dabei kommt jetzt das Ownership-Konzept von Rust ins Spiel.
    Wenn ein Thread eine Variable an einen anderen Thread schickt, wird dieser zum Besitzer der Variable.
    Das heisst wenn der erste Thread die Variable nach der Übertragung verwendet, gibt es einen Kompilierungsfehler.
    Im Crate `rust/example-channels` ist ein Beispiel dazu.

    \subsection{Patterns \& Matching}\label{subsec:patterns-&-matching}

    \subsection{Cargo: Test \& Build}\label{subsec:cargo:-test-&-build}

%    Ihr technisches Team-Fazit

    \section{Team-Fazit}\label{sec:team-fazit}
    Memory-Safety ist der Verkaufsgrund von Rust.
    Das ist etwas was andere Sprachen auf diesem Level nicht haben.
    Dies macht Rust zu einer modernen Sprache, was für die neue Generation von Entwicklern sehr attraktiv ist.

    Durch die Unterstützung im Linux-Kernel und die Gründung der Rust Foundation, konnte Rust den Grundstein legen.
    Jetzt ist Rust im Aufschwung und wird immer mehr verbreitet.
    2020 war Rust noch auf Platz 35 der meistverwendeten Sprachen auf GitHub.
    Seit Ende 2023 ist Rust jetzt auf Platz 20. \footnote{https://innovationgraph.github.com/global-metrics/programming-languages}.
    Aktuell verwenden etwas mehr als 13\% befragter Entwickler Rust. \footnote{https://survey.stackoverflow.co/2023/\#technology}
% Persönliches Fazit (je min. 1 Abschnitt pro Team-Mitglied)


    \section{Persönliches Fazit}\label{sec:personliches-fazit}

    \subsection{Roman Schilter}\label{subsec:roman}
    Ich habe wenig bis keine Erfahrung mit Low-Level Sprachen, von daher war das Ownership-Konzept gewöhnungsbedürftig.
    Der Garbage-Collector hat das Thema für mich immer sauber abstrahiert und ich musste mir nie Gedanken um Memory-Leaks oder ähnliches machen.
    Von daher bin ich froh, dass ich mir bei Rust auch keine Gedanken darüber machen muss.

    Die Syntax von Rust ist verständlich und intuitiv.
    Im Gegensatz zu zum Beispiel Clojure, dessen Syntax komplett anders ist, als was ich bisher kannte.
    Einzig die Pipes bei Lambda-Ausdrücken waren etwas gewöhnungsbedürftig.

    Sich mit Rust auseinander zusetzen hat Spass gemacht und ich kann Rust empfehlen.
    Wenn ich jemals in den Genuss komme, auf Lowlevel zu Programmieren und die Auswahl zwischen C, C++ oder Rust habe,
        würde ich Rust wählen.

    \subsection{Jan-Henrik Preuß}\label{subsec:jan}

%++++++++++++++++++++++++++++++++++++++++
% References section will be created automatically
% with inclusion of "thebibliography" environment
% as it shown below. See text starting with line
% \begin{thebibliography}{99}
% Note: with this approach it is YOUR responsibility to put them in order
% of appearance.

%    \begin{thebibliography}{99}
%
%        \bibitem{melissinos}
%        A.~C. Melissinos and J. Napolitano, \textit{Experiments in Modern Physics},
%        (Academic Press, New York, 2003).
%
%        \bibitem{Cyr}
%        N.\ Cyr, M.\ T$\hat{e}$tu, and M.\ Breton,
%% "All-optical microwave frequency standard: a proposal,"
%        IEEE Trans.\ Instrum.\ Meas.\ \textbf{42}, 640 (1993).
%
%        \bibitem{Wiki} \emph{Expected value},  available at
%        \texttt{http://en.wikipedia.org/wiki/Expected\_value}.
%
%    \end{thebibliography}


\end{document}
